<html>

<head>
	<title> Importing GLTF formats </title>
	<style>
		body {
			margin: 0;
		}

		#number {
			position: absolute;
			z-index: -1;
		}

		canvas {
			width: 100%;
			height: 100px;
			display: block;
		}
	</style>
</head>

<body>
	<canvas id="number"></canvas>

	<script src="js/three.js"> </script>
	<script src="js/OrbitControls.js"> </script>
	<script src="https://cdn.rawgit.com/mrdoob/three.js/master/examples/js/loaders/GLTFLoader.js"> </script>
	<script>
		function fillWithPoints(geometry, count) {
		  
		  var ray = new THREE.Ray()
		  
		  var size = new THREE.Vector3();
		  geometry.computeBoundingBox();
		  let bbox = geometry.boundingBox;
		  
		  let points = [];
		  
		  var dir = new THREE.Vector3(1, 1, 1).normalize();
		  for (let i = 0; i < count; i++) {
			let p = setRandomVector(bbox.min, bbox.max);
			points.push(p);
		  }
		  
		  function setRandomVector(min, max){
			let v = new THREE.Vector3(
			  THREE.Math.randFloat(min.x, max.x),
			  THREE.Math.randFloat(min.y, max.y),
			  THREE.Math.randFloat(min.z, max.z)
			);
			if (!isInside(v)){return setRandomVector(min, max);}
			return v;
		  }
		  
		  function isInside(v){
			
			ray.set(v, dir);
			let counter = 0;
			
			let pos = geometry.attributes.position;
			let faces = pos.count / 3;
			console.log(faces);
			let vA = new THREE.Vector3(), vB = new THREE.Vector3(), vC = new THREE.Vector3();
			for(let i = 0; i < faces; i++){
			  vA.fromBufferAttribute(pos, i * 3 + 0);
			  vB.fromBufferAttribute(pos, i * 3 + 1);
			  vC.fromBufferAttribute(pos, i * 3 + 2);
			  if (ray.intersectTriangle(vA, vB, vC)) counter++;
			}
			
			return counter % 2 == 1;
		  }
		  
		  return new THREE.BufferGeometry().setFromPoints(points);
		}
	  </script>
	<script>

		const canvas = document.getElementById("number");

		let camera;
		let controls;
		let scene;
		let renderer;
		let mesh;


		init();
		animate();

		function init() {

			// Camera
			camera = new THREE.PerspectiveCamera(55, window.innerWidth / window.innerHeight, 1, 1000);
			camera.position.x = 7;
			camera.position.y = 6;
			camera.position.z = 5;

			// Scene
			scene = new THREE.Scene();

			// Lights
			const lights = [];
			lights[0] = new THREE.PointLight(0xffffff, 1, 0);
			lights[1] = new THREE.PointLight(0xffffff, 1, 0);
			lights[2] = new THREE.PointLight(0xffffff, 1, 0);

			lights[0].position.set(0, 2, 0);
			lights[1].position.set(1, 2, 1);
			lights[2].position.set(-1, -2, -1);

			scene.add(lights[0]);
			scene.add(lights[1]);
			scene.add(lights[2]);

			// Axes Helper
			//var axesHelper = new THREE.AxesHelper( 10 );
			//scene.add( axesHelper );

			// Instantiate a loader
			var loader = new THREE.GLTFLoader();

			// Load a glTF resource
			loader.load(
				// resource URL
				'models/myPipe.gltf',
				// called when the resource is loaded
				function (gltf) {
					gltf.scene.traverse(function (child) {
						if (child.isMesh) {
							mesh = gltf.scene.children[2];
							mesh.scale.set( 3, 3, 2 );
							//mesh.rotation.x = 1.4;
							//mesh.rotation.y = 0.1;
							//mesh.rotation.z = 1.1;
							//mesh.children[1].material.depthTest=false
							mesh.material.transparent = true;
							mesh.material.opacity = 0.5;
							var geometry = mesh.geometry.toNonIndexed();
							scene.add(mesh);

							// ##########
							// # CUSTOM #
							// ##########

							var pointsGeom = fillWithPoints(geometry, 500);
							//console.log(pointsGeom);
							var pointsMat = new THREE.PointsMaterial({color: "aqua", size: 0.25});
							var points = new THREE.Points(pointsGeom, pointsMat);
							mesh.add(points);

						}
					});
				},
				// called while loading is progressing
				function (xhr) {
					console.log((xhr.loaded / xhr.total * 100) + '% loaded');
				},
				// called when loading has errors
				function (error) {
					console.log('An error happened');
					console.log(error);
				}
			);

			// ##########
			// # CUSTOM #
			// ##########


			// Renderer
			renderer = new THREE.WebGLRenderer({ antialias: true });
			renderer.setPixelRatio(window.devicePixelRatio);
			renderer.setSize(window.innerWidth, window.innerHeight);
			renderer.setClearColor(0x333333, 1);
			document.body.appendChild(renderer.domElement);

			// Orbit Controls		
			controls = new THREE.OrbitControls(camera, renderer.domElement);
			//controls.update() must be called after any manual changes to the camera's transform
			//camera.position.set( 0, 20, 70 );
			//controls.update();

			window.addEventListener("resize", onWindowResize, false);
		}

		function onWindowResize() {
			camera.aspect = window.innerWidth / window.innerHeight;
			camera.updateProjectionMatrix();

			renderer.setSize(window.innerWidth, window.innerHeight);
		}

		function animate() {
			requestAnimationFrame(animate);
			controls.update();

			render();
		}

		function render() {
			renderer.render(scene, camera);
		}
		
	</script>
</body>

</html>