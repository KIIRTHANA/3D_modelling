<html>
	<head>
		<title> Importing GLTF formats </title>
		<style>
			body {
				margin: 0;
			}
			#number {
				position: absolute;
    			z-index: -1;
			}
			canvas {
				width: 100%;
		    	height: 100px;
				display: block;
			}

			.annotation {
			    position: absolute;
			    top: 0;
			    left: 0;
			    z-index: 1;
			    margin-left: 15px;
			    margin-top: 15px;
			    padding: 1em;
			    width: 200px;
			    color: #fff;
			    background: rgba(0, 0, 0, 0.8);
			    border-radius: 0.5em;
			    font-style: "Calibri"
			    font-size: 12px;
			    line-height: 1.2;
				
		    transition: opacity 0.5s;
			    &::before {
		        	content: "1";
			        position: absolute;
			        top: -30px;
			        left: -30px;
			        width: 30px;
			        height: 30px;
			        border: 2px solid #fff;
			        border-radius: 50%;
			        font-size: 16px;
			        line-height: 30px;
			        text-align: center;
			        background: rgba(0, 0, 0, 0.8);
			    }
			}
		</style>
	</head>
	<body>
		<div class="annotation" hidden="true" id="cube">
		    <p><strong>Cube</strong></p>
		    <p>Hey there!, I am cube and I was made in THREE.JS :)</p>
		</div>
		<div class="annotation" hidden="true" id="pipe">
			<p><strong>Pipe</strong></p>
			<p>Hey there!, I am pipe and I was made in blender and exported here :)</p>
		</div>
		<canvas id="number"></canvas>
		
		<script src="js/three.js" > </script>
		<script src="js/OrbitControls.js"> </script>
		<script src="https://cdn.rawgit.com/mrdoob/three.js/master/examples/js/loaders/GLTFLoader.js"> </script>
		<script>

			const canvas = document.getElementById("number");

			var mouse = new THREE.Vector2(), INTERSECTED, raycaster;

			let camera;
			let controls;
			let scene;
			let renderer;
			let sprite;
			let mesh, mesh1;
			let spriteBehindObject;
			const annotation = document.querySelector(".annotation");

			const ctx = canvas.getContext('2d');
			const x = 32;
			const y = 32;
			const radius = 30;
			const startAngle = 0;
			const endAngle = Math.PI * 2;

			ctx.fillStyle = 'rgb(0, 0, 0)';
			ctx.beginPath();
			ctx.arc(x, y, radius, startAngle, endAngle);
			ctx.fill();

			ctx.strokeStyle = 'rgb(255, 255, 255)';
			ctx.lineWidth = 3;
			ctx.beginPath();
			ctx.arc(x, y, radius, startAngle, endAngle);
			ctx.stroke();

			ctx.fillStyle = 'rgb(255, 255, 255)';
			ctx.font = '32px sans-serif';
			ctx.textAlign = 'center';
			ctx.textBaseline = 'middle';
			ctx.fillText('1', x, y);

			init();
			animate();

			function init() {
		    
			    // Camera

			    camera = new THREE.PerspectiveCamera(55, window.innerWidth / window.innerHeight, 2, 10000);
			    camera.position.x = 750;
			    camera.position.y = 700;
			    camera.position.z = 1250;
			    camera.lookAt(0,0,0);
				
				// Scene
				scene = new THREE.Scene();
				
				// Lights
				const lights = [];
				lights[0] = new THREE.PointLight(0xffffff, 1, 0);
				lights[1] = new THREE.PointLight(0xffffff, 1, 0);
				lights[2] = new THREE.PointLight(0xffffff, 1, 0);


				lights[0].position.set(0, 2000, 0);
				lights[1].position.set(1000, 2000, 1000);
				lights[2].position.set(-1000, -2000, -1000);

				scene.add(lights[0]);
				scene.add(lights[1]);
				scene.add(lights[2]);

				// Axes Helper
				var axesHelper = new THREE.AxesHelper( 1000 );
				scene.add( axesHelper );
				
				// Instantiate a loader
				var loader = new THREE.GLTFLoader();

				// Load a glTF resource
				loader.load(
					// resource URL
					'models/myPipe.gltf',
					// called when the resource is loaded
					function ( gltf ) {
						gltf.scene.traverse( function ( child ) {
							if ( child.isMesh ) {
							mesh2 = child;
							mesh2.material.color.setHex(0x493ab4);
							mesh2.scale.set( 200, 200, 2400 );
							mesh2.rotation.x = 0;
							mesh2.rotation.y = 0;
							mesh2.rotation.z = 0;
							scene.add( mesh2 );
						}});
					},
					// called while loading is progressing
					function ( xhr ) {
						console.log( ( xhr.loaded / xhr.total * 100 ) + '% loaded' );
					},
					// called when loading has errors
					function ( error ) {
						console.log( 'An error happened' );
					}
				);

				// Mesh

			    var cubeGeometry = new THREE.BoxGeometry(500, 500, 500);
				var cubeGeometry1 = new THREE.BoxGeometry(700, 700, 700);
			    var material = new THREE.MeshPhongMaterial({
			            color: 0x156289,
			            emissive: 0x072534,
			            side: THREE.DoubleSide,
			            flatShading: THREE.FlatShading,
			            //wireframe : true
			        });
			    mesh1 = new THREE.Mesh(cubeGeometry,material);

				mesh1.position.set(600, 0, 0);
				
			    scene.add(mesh1);

				raycaster = new THREE.Raycaster();

				// Renderer
			    renderer = new THREE.WebGLRenderer({ antialias: true });
			    renderer.setPixelRatio(window.devicePixelRatio);
			    renderer.setSize(window.innerWidth, window.innerHeight);
			    renderer.setClearColor(0xfdb975, 1);
			    document.body.appendChild(renderer.domElement);

				// Orbit Controls		
				controls = new THREE.OrbitControls( camera, renderer.domElement);
				//controls.update() must be called after any manual changes to the camera's transform
				//camera.position.set( 0, 20, 70 );
				controls.update();

				document.addEventListener( 'mousedown', onDocumentMouseDown, false );

				window.addEventListener("resize", onWindowResize, false);
			} 

			function onDocumentMouseDown( event ) {

				event.preventDefault();

				mouse.x = ( event.clientX / window.innerWidth ) * 2 - 1;
				mouse.y = - ( event.clientY / window.innerHeight ) * 2 + 1;

				raycaster.setFromCamera( mouse, camera );

				var intersects = raycaster.intersectObjects( scene.children );

				var color = (Math.random() * 0xffffff);

				if(intersects.length > 1) {
					if (intersects[0].object == mesh1) {
						intersects[0].object.material.color.setHex( color );
						mesh2.material.color.setHex(0x493ab4);
						document.getElementById("cube").style.display = "block";
						document.getElementById("pipe").style.display = "none";
					}
					else
					{
						intersects[0].object.material.color.setHex( color );
						mesh1.material.color.setHex(0x493ab4);
						document.getElementById("cube").style.display = "none";
						document.getElementById("pipe").style.display = "block";
					}
				}
				else
				{
					mesh2.material.color.setHex(0x493ab4);
					mesh1.material.color.setHex(0x156289);
					document.getElementById("cube").style.display = "none";
					document.getElementById("pipe").style.display = "none";
				}

			}

			function onWindowResize() {
			    camera.aspect = window.innerWidth / window.innerHeight;
			    camera.updateProjectionMatrix();

			    renderer.setSize(window.innerWidth, window.innerHeight);
			}	
			
			function animate() {
				requestAnimationFrame( animate );
				controls.update();
				//annotation.hidden(false);
				render();
			}

			function render() {
				renderer.render(scene, camera);
				//updateAnnotationOpacity();
    			updateScreenPosition();
			}

			/*function updateAnnotationOpacity() {
			    const meshDistance = camera.position.distanceTo(mesh.position);
			    const spriteDistance = camera.position.distanceTo(sprite.position);
			    spriteBehindObject = spriteDistance > meshDistance;
			    sprite.material.opacity = spriteBehindObject ? 0.25 : 1;

			    // Do you want a number that changes size according to its position?
			    // Comment out the following line and the `::before` pseudo-element.
			    sprite.material.opacity = 0;
			}*/

			function updateScreenPosition() {
			    //Coordinates of Cube Annotation
				const vector = new THREE.Vector3(600, 400, 120);
			    const canvas = renderer.domElement;

			    vector.project(camera);

			    vector.x = Math.round((0.5 + vector.x / 2) * (canvas.width / window.devicePixelRatio));
			    vector.y = Math.round((0.5 - vector.y / 2) * (canvas.height / window.devicePixelRatio));

			    cube.style.top = `${vector.y}px`;
			    cube.style.left = `${vector.x}px`;
			    cube.style.opacity = spriteBehindObject ? 0.25 : 1;

				//Coordinates of  Pipe Annotations
				const vector1 = new THREE.Vector3(-250, 200, 120);
			    const canvas1 = renderer.domElement;

			    vector1.project(camera);

			    vector1.x = Math.round((0.5 + vector1.x / 2) * (canvas1.width / window.devicePixelRatio));
			    vector1.y = Math.round((0.5 - vector1.y / 2) * (canvas1.height / window.devicePixelRatio));

				pipe.style.top = `${vector1.y}px`;
			    pipe.style.left = `${vector1.x}px`;
			    pipe.style.opacity = spriteBehindObject ? 0.25 : 1;
			}
	</script>
</body>
</html>
	