<html>

<head>
	<title> Importing GLTF formats </title>
	<style>
		body {
			margin: 0;
		}

		#number {
			position: absolute;
			z-index: -1;
		}

		canvas {
			width: 100%;
			height: 100px;
			display: block;
		}
	</style>
</head>

<body>
	<canvas id="number"></canvas>

	<script src="js/three.js"> </script>
	<script src="js/OrbitControls.js"> </script>
	<script src="https://cdn.rawgit.com/mrdoob/three.js/master/examples/js/loaders/GLTFLoader.js"> </script>
	<script>
		
	  </script>
	<script>

		const canvas = document.getElementById("number");

		let camera;
		let controls;
		let scene;
		let renderer;
		let mesh;
		let texture;

		init();
		animate();

		function init() {

			// Camera
			camera = new THREE.PerspectiveCamera(55, window.innerWidth / window.innerHeight, 0.1, 1000);
			camera.position.x = 7;
			camera.position.y = 6;
			camera.position.z = 5;

			// Scene
			scene = new THREE.Scene();

			// Lights
			const lights = [];
			lights[0] = new THREE.PointLight(0xffffff, 1, 0);
			lights[1] = new THREE.PointLight(0xffffff, 1, 0);
			lights[2] = new THREE.PointLight(0xffffff, 1, 0);

			lights[0].position.set(0, 2, 0);
			lights[1].position.set(1, 2, 1);
			lights[2].position.set(-1, -2, -1);

			scene.add(lights[0]);
			scene.add(lights[1]);
			scene.add(lights[2]);

			// Axes Helper
			//var axesHelper = new THREE.AxesHelper( 10 );
			//scene.add( axesHelper );

			// Instantiate a loader
			var loader = new THREE.GLTFLoader();

			// ** CUSTOM ** 
			// make a texture with an arrow
			const ctx = canvas.getContext("2d");
			ctx.canvas.width = 64;
			ctx.canvas.height = 64;

			ctx.fillStyle = "rgba(0,0,255,0.5)";
			ctx.fillRect(0, 0, 264, 164);

			ctx.translate(25, 25);
			ctx.rotate(Math.PI * .5);
			ctx.fillStyle = "rgb(0,255,255)";
			ctx.textAlign = "center";
			ctx.textBaseline = "middle";
			ctx.font = "71px sans-serif";
			ctx.fillText("âž¡", 0, 0);

			texture = new THREE.CanvasTexture(ctx.canvas);
			texture.wrapS = THREE.RepeatWrapping;
			texture.wrapT = THREE.RepeatWrapping;
			//texture.repeat.x = 0.50;
			texture.repeat.y = 5;
			//texture.repeat.z = 10;

			// Load a glTF resource
			loader.load(
				// resource URL
				'models/myPipe.gltf',
				// called when the resource is loaded
				function (gltf) {
					gltf.scene.traverse(function (child) {
						if (child.isMesh) {
							mesh = gltf.scene.children[2];
							//mesh.scale.set( 3, 3, 2 );
							//mesh.rotation.x = 0.6;
							mesh.rotation.y = 1.57;
							//mesh.rotation.z = 1;
							
							//mesh.material.depthTest=false
							//mesh.material.transparent = true;
							//mesh.material.opacity = 0.5;
							//var geometry = mesh.geometry;
							//scene.add(mesh);
							
							// CUSTOM
							const material = new THREE.MeshBasicMaterial({
								map: texture,
								side: THREE.DoubleSide,
								//depthWrite: false,
								//depthTest: false,
								//transparent: true,
							});
							mesh.material = material;
							scene.add(mesh);

							// ##########
							// # CUSTOM #
							// ##########
							//const radiusTop = 1;
							//const radiusBottom = 1;
							//const height = 5;
							//const radiusSegments = 20;
							//const heightSegments = 2;
							//const openEnded = true;
							//const geometrys = new THREE.CylinderBufferGeometry( 
							//radiusTop, radiusBottom, height, radiusSegments, heightSegments, openEnded);
							//const geometrys = (new THREE.Geometry()).fromBufferGeometry(mesh.geometry);
							//const materials = new THREE.MeshBasicMaterial({
							//	map: texture,
							//	side: THREE.DoubleSide,
							//	depthWrite: false,
							//	depthTest: false,
							//	transparent: true,
							//});
							//const sd = new THREE.Mesh(geometrys, materials);
							//scene.add(sd);
							//sd.rotation.z = Math.PI * .5;

							//mesh.geometry = geometrys;
							
						}
					});
				},
				// called while loading is progressing
				function (xhr) {
					console.log((xhr.loaded / xhr.total * 100) + '% loaded');
				},
				// called when loading has errors
				function (error) {
					console.log('An error happened');
					console.log(error);
				}
			);


			

			// Renderer
			renderer = new THREE.WebGLRenderer({ antialias: true });
			renderer.setPixelRatio(window.devicePixelRatio);
			renderer.setSize(window.innerWidth, window.innerHeight);
			renderer.setClearColor(0x333333, 1);
			document.body.appendChild(renderer.domElement);

			// Orbit Controls		
			controls = new THREE.OrbitControls(camera, renderer.domElement);
			//controls.update() must be called after any manual changes to the camera's transform
			//camera.position.set( 0, 20, 70 );
			controls.update();

			window.addEventListener("resize", onWindowResize, false);
		}

		function onWindowResize() {
			camera.aspect = window.innerWidth / window.innerHeight;
			camera.updateProjectionMatrix();

			renderer.setSize(window.innerWidth, window.innerHeight);
		}

		function animate() {
			requestAnimationFrame(animate);
			controls.update();

			requestAnimationFrame(render);
		}

		function render(time) {
			time *= 0.001;
			texture.offset.y = (time * 3 % 1);
			
			renderer.render(scene, camera);
		}
		
	</script>
</body>

</html>