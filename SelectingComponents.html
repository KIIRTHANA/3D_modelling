<html>
	<head>
		<title> Importing GLTF formats </title>
		<style>
			body {
				margin: 0;
			}
			#number {
				position: absolute;
    			z-index: -1;
			}
			canvas {
				width: 100%;
		    	height: 100px;
				display: block;
			}

			.annotation {
			    position: absolute;
			    top: 0;
			    left: 0;
			    z-index: 1;
			    margin-left: 15px;
			    margin-top: 15px;
			    padding: 1em;
			    width: 200px;
			    color: #fff;
			    background: rgba(0, 0, 0, 0.8);
			    border-radius: 0.5em;
			    font-style: "Calibri"
			    font-size: 12px;
			    line-height: 1.2;
		    transition: opacity 0.5s;
			    &::before {
		        	content: "1";
			        position: absolute;
			        top: -30px;
			        left: -30px;
			        width: 30px;
			        height: 30px;
			        border: 2px solid #fff;
			        border-radius: 50%;
			        font-size: 16px;
			        line-height: 30px;
			        text-align: center;
			        background: rgba(0, 0, 0, 0.8);
			    }
			}
		</style>
	</head>
	<body>
		<div class="annotation">
		    <p><strong>Pipe Model 2</strong></p>
		    <p>Hey there!, I am pipe and I was made in blender and exported here :)</p>
		</div>
		<canvas id="number"></canvas>
		
		<script src="js/three.js" > </script>
		<script src="js/OrbitControls.js"> </script>
		<script src="https://cdn.rawgit.com/mrdoob/three.js/master/examples/js/loaders/GLTFLoader.js"> </script>
		<script>

			const canvas = document.getElementById("number");

			var mouse = new THREE.Vector2(), INTERSECTED, raycaster;

			let camera;
			let controls;
			let scene;
			let renderer;
			let sprite;
			let mesh, mesh1;
			let spriteBehindObject;
			const annotation = document.querySelector(".annotation");

			const ctx = canvas.getContext('2d');
			const x = 32;
			const y = 32;
			const radius = 30;
			const startAngle = 0;
			const endAngle = Math.PI * 2;

			ctx.fillStyle = 'rgb(0, 0, 0)';
			ctx.beginPath();
			ctx.arc(x, y, radius, startAngle, endAngle);
			ctx.fill();

			ctx.strokeStyle = 'rgb(255, 255, 255)';
			ctx.lineWidth = 3;
			ctx.beginPath();
			ctx.arc(x, y, radius, startAngle, endAngle);
			ctx.stroke();

			ctx.fillStyle = 'rgb(255, 255, 255)';
			ctx.font = '32px sans-serif';
			ctx.textAlign = 'center';
			ctx.textBaseline = 'middle';
			ctx.fillText('1', x, y);

			init();
			animate();

			function init() {
		    
			    // Camera

			    camera = new THREE.PerspectiveCamera(55, window.innerWidth / window.innerHeight, 2, 2000);
			    camera.position.x = 750;
			    camera.position.y = 500;
			    camera.position.z = 1250;
				
				// Scene
				scene = new THREE.Scene();
				
				// Lights
				const lights = [];
				lights[0] = new THREE.PointLight(0xffffff, 1, 0);
				lights[1] = new THREE.PointLight(0xffffff, 1, 0);
				lights[2] = new THREE.PointLight(0xffffff, 1, 0);

				lights[0].position.set(0, 2000, 0);
				lights[1].position.set(1000, 2000, 1000);
				lights[2].position.set(-1000, -2000, -1000);

				scene.add(lights[0]);
				scene.add(lights[1]);
				scene.add(lights[2]);

				// Axes Helper
				//var axesHelper = new THREE.AxesHelper( 10 );
				//scene.add( axesHelper );
				
				// Instantiate a loader
				var loader = new THREE.GLTFLoader();

				// Load a glTF resource
				loader.load(
					// resource URL
					'models/myPipe.gltf',
					// called when the resource is loaded
					function ( gltf ) {
						gltf.scene.traverse( function ( child ) {
							if ( child.isMesh ) {
							mesh = gltf.scene;
							mesh.scale.set( 210, 350, 240 );
							mesh.rotation.x = 1.4;
							mesh.rotation.y = 0.1;
							mesh.rotation.z = 1.1;
							scene.add( mesh );
						}});
					},
					// called while loading is progressing
					function ( xhr ) {
						console.log( ( xhr.loaded / xhr.total * 100 ) + '% loaded' );
					},
					// called when loading has errors
					function ( error ) {
						console.log( 'An error happened' );
					}
				);

				// Mesh

			    const cubeGeometry = new THREE.BoxGeometry(500, 500, 500);

			    mesh1 = new THREE.Mesh(
			        cubeGeometry,
			        new THREE.MeshPhongMaterial({
			            color: 0x156289,
			            emissive: 0x072534,
			            side: THREE.DoubleSide,
			            shading: THREE.FlatShading
			        })
			    );
				mesh1.position.set(122, 233, 222);
				
			    scene.add(mesh1);

				raycaster = new THREE.Raycaster();

				// Renderer
			    renderer = new THREE.WebGLRenderer({ antialias: true });
			    renderer.setPixelRatio(window.devicePixelRatio);
			    renderer.setSize(window.innerWidth, window.innerHeight);
			    renderer.setClearColor(0x333333, 1);
			    document.body.appendChild(renderer.domElement);

				// Orbit Controls		
				controls = new THREE.OrbitControls( camera, renderer.domElement);
				//controls.update() must be called after any manual changes to the camera's transform
				//camera.position.set( 0, 20, 70 );
				//controls.update();

				document.addEventListener( 'mousemove', onDocumentMouseMove, false );

				window.addEventListener("resize", onWindowResize, false);
			}

			function onDocumentMouseMove( event ) {

			event.preventDefault();

			mouse.x = ( event.clientX / window.innerWidth ) * 2 - 1;
			mouse.y = - ( event.clientY / window.innerHeight ) * 2 + 1;

			}

			function onWindowResize() {
			    camera.aspect = window.innerWidth / window.innerHeight;
			    camera.updateProjectionMatrix();

			    renderer.setSize(window.innerWidth, window.innerHeight);
			}	
			
			function animate() {
				requestAnimationFrame( animate );
				controls.update();
				
				render();
			}

			function render() {
				renderer.render(scene, camera);
				//updateAnnotationOpacity();
    			updateScreenPosition();

				raycaster.setFromCamera( mouse, camera );

				var intersects = raycaster.intersectObjects( scene.children );

				// INTERSECTED = the object in the scene currently closest to the camera 
				//      and intersected by the Ray projected from the mouse position    

				// if there is one (or more) intersections
				if ( intersects.length > 0 )
				{
				    // if the closest object intersected is not the currently stored intersection object
				    if ( intersects[ 0 ].object != INTERSECTED )
				    {
				        // restore previous intersection object (if it exists) to its original color
				        if ( INTERSECTED )
				            INTERSECTED.material.color.setHex( INTERSECTED.currentHex );
				        // store reference to closest object as current intersection object
				        INTERSECTED = intersects[ 0 ].object;
				        // store color of closest object (for later restoration)
				        INTERSECTED.currentHex = INTERSECTED.material.color.getHex();
				        // set a new color for closest object
				        INTERSECTED.material.color.setHex( 0xffff00 );
				    }
				}
				else // there are no intersections
				{
				    // restore previous intersection object (if it exists) to its original color
				    if ( INTERSECTED )
				        INTERSECTED.material.color.setHex( INTERSECTED.currentHex );
				    // remove previous intersection object reference
				    //     by setting current intersection object to "nothing"
				    INTERSECTED = null;
}
			}

			/*function updateAnnotationOpacity() {
			    const meshDistance = camera.position.distanceTo(mesh.position);
			    const spriteDistance = camera.position.distanceTo(sprite.position);
			    spriteBehindObject = spriteDistance > meshDistance;
			    sprite.material.opacity = spriteBehindObject ? 0.25 : 1;

			    // Do you want a number that changes size according to its position?
			    // Comment out the following line and the `::before` pseudo-element.
			    sprite.material.opacity = 0;
			}*/

			function updateScreenPosition() {
			    const vector = new THREE.Vector3(600, 400, 120);
			    const canvas = renderer.domElement;

			    vector.project(camera);

			    vector.x = Math.round((0.5 + vector.x / 2) * (canvas.width / window.devicePixelRatio));
			    vector.y = Math.round((0.5 - vector.y / 2) * (canvas.height / window.devicePixelRatio));

			    /*annotation.style.top = `${vector.y}px`;
			    annotation.style.left = `${vector.x}px`;
			    annotation.style.opacity = spriteBehindObject ? 0.25 : 1;*/
			}
	</script>
</body>
</html>
	